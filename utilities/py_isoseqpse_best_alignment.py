#!/usr/bin/env python
import sys,re,time,argparse

def main(args):
	sys.stdout.write("Start analysis: " + time.strftime("%a,%d %b %Y %H:%M:%S") + "\n")
	sys.stdout.flush()
	best_alignment(args.input,args.output)
	sys.stdout.write("Finish analysis: " + time.strftime("%a,%d %b %Y %H:%M:%S") + "\n")
	sys.stdout.flush()

def best_alignment(input_gpd,output_gpd):
	head = 1
	for line in input_gpd: # sort by -k1,1 -k15,15n -k16,16n
		if head:
			read_id = line.strip().split("\t")[0]
			error_read,error_ref = [float(i) for i in line.strip().split("\t")[-2:]]
			dic_read_line,dic_read_error_read,dic_read_error_ref = {},{},{}
			dic_read_line[read_id],dic_read_error_read[read_id],dic_read_error_ref[read_id] = [],[],[]
			dic_read_line[read_id].append(line.strip())
			dic_read_error_read[read_id].append(error_read)
			dic_read_error_ref[read_id].append(error_ref)
			head -= 1
			continue
		if line.strip().split("\t")[0] != read_id:
			if len(dic_read_line[read_id]) == 1: # uniquely map
				print >>output_gpd, dic_read_line[read_id][0] + "\tU"
			else:
				if dic_read_error_read[read_id][0] < dic_read_error_read[read_id][1]: # error in read sequence
					print >>output_gpd, dic_read_line[read_id][0] + "\tM"
				else:
					if dic_read_error_ref[read_id][0] < dic_read_error_ref[read_id][1]: # error in ref sequence
						print >>output_gpd, dic_read_line[read_id][0] + "\tM"
			read_id = line.strip().split("\t")[0]
			error_read,error_ref = [float(i) for i in line.strip().split("\t")[-2:]]
			dic_read_line,dic_read_error_read,dic_read_error_ref = {},{},{}
			dic_read_line[read_id],dic_read_error_read[read_id],dic_read_error_ref[read_id] = [],[],[]
			dic_read_line[read_id].append(line.strip())
			dic_read_error_read[read_id].append(error_read)
			dic_read_error_ref[read_id].append(error_ref)

		else:
			dic_read_line[read_id].append(line.strip())
			dic_read_error_read[read_id].append(error_read)
			dic_read_error_ref[read_id].append(error_ref)

	input_gpd.close()
	output_gpd.close()

def do_inputs():
	output_gpd_format = '''
1. read id
2. read id
3. chromosome id
4. strand
5. start site of alignment
6. end site of alignment
7. MAPQ 
8. number of nucleotides that are softly-clipped by aligner; left_right
9. exon count
10. exon start set
11. exon end set
12. sam flag
13. error in read sequence
14. error in reference genome sequence
15. error rate in read sequence
16. error rate in reference genome sequence
17. unique ('U') or multiple 'M' alignment'''

	parser = argparse.ArgumentParser(description="Function: get best one alignment for each read",formatter_class=argparse.ArgumentDefaultsHelpFormatter)
	parser.add_argument('-i','--input',type=argparse.FileType('r'),required=True,help="Input: long read gpd fiel generated by 'py_isoseqpse_sam2gpd_pacbio.py', then must be 'sort -k1,1 -k15,15n -k16,16n'")
	parser.add_argument('-o','--output',type=argparse.FileType('w'),required=True,help="Output: gpd file with best alignment (at most one) for each read")
	args = parser.parse_args()
	return args

if __name__=="__main__":
	args = do_inputs()
	main(args)
